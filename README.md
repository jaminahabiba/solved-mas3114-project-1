Download Link: https://assignmentchef.com/product/solved-mas3114-project-1
<br>
<strong>BEGIN</strong> with creating Live Script <strong>Project1. </strong>

<u>Note</u>: All exercises in this project will be completed in the Live Script using the Live Editor.

Please refer to the MATLAB video that explains how to use the Live Script:

<a href="https://www.mathworks.com/videos/using-the-live-editor-117940.html?s_tid=srchtitle">https://www.mathworks.com/videos/using-the-live-editor-117940.html?s_tid=srchtitle</a> <strong>The final script has to be generated by exporting the Live Script to PDF.</strong>




Each exercise has to begin with the line

<strong>Exercise#</strong>

You should also mark down the parts such as (a), (b), (c), and etc. This makes grading easier. <strong><u>Important</u>: we use the default </strong>format short<strong> for the numbers in all exercises unless it is specified otherwise</strong>. We <u>do not employ</u> format rat since it may cause problems with running the codes and displaying matrices in Live Script. If format long has been used, please make sure to return to the default format in the next exercise.

.

<strong>E</strong><strong>XERCISE1</strong>

<em>Jordan Block</em> is a square <em>n n</em><sub>×</sub> matrix (<em>n</em><sub>≥</sub>2) with a scalar r on the main diagonal and 1’s on the diagonal right above it. All other entries are zero.

**Create a function in a file that begins with function J=jord(n,r)




which, when possible, produces an <em>n n</em><sub>×</sub> Jordan matrix with a scalar r on its main diagonal.




**First, the function will verify whether <em>n</em><sub>&gt;</sub>1 and <em>n</em> is an integer number. You can use a builtin MATLAB function such as mod or fix .

**If n does not satisfies the above conditions, the code has to assign an empty matrix to J and display a message that ‘Jordan Block cannot be built’- you can use disp, sprintf, or fprintf commands.

**If n is an integer number and <em>n </em><sub>&gt;</sub>1, you will proceed with constructing a Jordan Block matrix J as described at the beginning of this exercise.




After the function jord  is created and saved in a file, we return to the Live Script.

**First, we set the format mode by typing

format format compact

**Then, we print in the Live Script the created function <strong>jord</strong> by typing

type jord

**Next, we input

r=rand(1)

and run the function J=jord(n,r)  for each of the following n to get either a non-empty output J or an empty matrix and a message that Jordan Block cannot be built:

<ul>

 <li>n=0;</li>

 <li>n=-2;</li>

 <li>n=3.5;</li>

 <li>n=-2.5;</li>

 <li>n=4;</li>

</ul>

<strong> </strong>

DESCRIPTION: In this part of the project, you will create a function <strong>added</strong> in a file. You will code the sum of two matrices A and B, when they are of the same size, <u>by using any of these</u> <u>two definitions</u>: (1) the sum of A and B is the matrix C whose columns are the sums of the corresponding columns of A and B or (2) the sum of A and B is the matrix C whose entries are the sums of the corresponding entries of the matrices A and B. Then, you will verify if your output matrix C matches the output of a MATLAB built-in function for the sum, A+B.




**Create the function which begins with:

function C = added(A,B)




**First, your function has to verify whether the input matrices A and B have the same size. If not, output a message ‘the matrices are not of the same size and cannot be added’, and assign an empty matrix to C. After that, the program <u>terminates</u>.




**If the matrices can be added, you will continue with calculating the sum C of A and B using <u>one of the two definitions</u> of the sum of two matrices (see above) – to code it, you can employ “for” loop or vectorized statement. Output and <u>display</u> the matrix C.




**Next, you will use a logical “if” statement to verify whether the calculated matrix C matches the output for a built-in MATLAB function A+B. If the outputs C and A+B <u>do not</u> <u>match</u>, program an output message ‘check the code!’ – use  disp or fprintf commands – and, if you receive this message, you will need to correct the code and re-run Section.

<strong>This will be the end of your function </strong>added<strong>. </strong>Save it in your Current folder in MATLAB.




<strong>The rest of the work has to be done in the Live Script. </strong>**Print your function in the Live Script:

**Run the function added on the following sets of variables:

<ul>

 <li>A=magic(3), B=ones(4)</li>

 <li>A=ones(3,4), B=ones(3,3)</li>

 <li>A=randi(100,3,4), B=randi(100,3,4)</li>

</ul>




**You should receive a non-empty output matrix C in part (c), and you will continue working <u>in the Live Script</u> with the matrices A, B, and C from part (c). You will “demonstrate” by means of <u>your function</u> added and logical statements that the Commutative and Distributive properties of the matrix addition hold (see (1)-(2) below):

<ul>

 <li>You will verify that the sum of A and B is the same as the sum of B and A. If it is the case, the program should output a message that ‘commutative property holds for the given A and B’.</li>

 <li>You will verify that the product of a scalar k by the matrix C, kC, is the same as the sum of kA and kB. If this is the case, your program will output a message that ‘distributive property holds for the given A and B’.</li>

</ul>

For this part you will need to input a scalar:

k=fix(10*rand(1))+5




<u>Note</u>: Make sure that you will receive the desired output messages for (1) and (2) above.

<strong> </strong>

<u>Theory</u>: The transformation defined by the matrix <em>A </em>=<sup></sup><sub></sub>sin<sup>cos</sup><sub>θ</sub><sup>θ </sup><sup>−</sup>cos<sup>sin</sup><sub>θ</sub><sup>θ</sup><sup> </sup><sub>  </sub>= <em><sup>c</sup>s </em><sup>−</sup><em>c</em><em><sup>s</sup></em><sup></sup><sub></sub> performs a

<sub></sub>

rotation in <em>x x</em><sub>1 2 </sub>− plane through the angle θ radians in the counterclockwise direction for a positive angle<sub>θ</sub>. The same type of a “plane” rotation in <em>xx</em><em><sub>i           j </sub></em>– plane can be performed in

¡<em><sup>n </sup></em>(<em>n </em>≥ 2, 1≤ &lt; ≤<em>i j    n</em>) , and it is called a Givens rotation.

A Givens rotation is represented by a matrix <em>G</em> which is defined by the following parameters: <em>n </em>(<em>n </em><sub>≥</sub>2), <em>theta </em>=θ (the angle of rotation), and <em>i j</em>,      (1<sub>≤ &lt; ≤</sub><em>i         j           n </em>). A matrix G can be created by starting with the <em>n n</em>× identity matrix, that is G=eye(n), and, then, assigning the entries of the matrix A to the entries of G at the intersections of rows <em>i j</em>,    with columns <em>i j</em>,        (<em>i </em><sub>&lt; </sub><em>j </em>) as follows:

G(i,i)=c; G(i,j)=-s; G(j,i)=s; G(j,j)=c;




<u>Geometrical Meaning</u>: The matrix-vector product of G and a column vector <em>x</em> in ¡<em><sup>n</sup></em> performs a rotation of <em>x </em>in the <em>x x</em><em><sub>i  j </sub></em>-plane through <sub>θ</sub> radians, affecting, possibly, only rows

(=entries) <em>i</em> and <em>j</em> in <em>x</em>.




**Write a MATLAB function which begins with the line function G=givensrot(n,i,j,theta)




and produces an <em>n n</em>× Givens matrix G under the conditions that 1<sub>≤ &lt; ≤</sub><em>i j n</em> and <em>n </em>≥2 – these conditions have to be verified in your code.

**If at least one of the conditions does not hold, the program outputs an empty matrix

G=[];

and <u>terminates</u> with an output message that Givens rotation matrix cannot be constructed.   **If all conditions hold, output and <u>display</u> the matrix G, as it specified in the <u>Theory</u> above.




**Print the function givensrot in your Live Script.




**Run the function  G=givensrot(n,i,j,theta) on each set of the variables in (1) – (5).

(Type <em>pi</em> for π in MATLAB.)

<ul>

 <li>n=1;i=1;j=2;theta=pi</li>

 <li>n=4;i=3;j=2;theta=pi/2</li>

 <li>n=5;i=2;j=4;theta=pi/4</li>

 <li>n=2;i=1;j=2;theta=-pi/2</li>

 <li>n=3;i=1;j=2;theta=pi</li>

</ul>




<strong>The rest of the work on this exercise has to be done in the <u>Live Script</u> using the output matrix G from part (5): </strong>

**Based on the Geometrical Meaning of the product of G and a vector, <u>predict</u> what would be the matrix (denote it GI) whose columns are the images of the vectors <em>e e</em><sub>1</sub>, <sub>2</sub>, <em>e</em><sub>3 </sub>, respectively, under the Givens rotation defined in part (5); here, <em>e e</em><sub>1</sub>, <sub>2</sub>, <em>e</em><sub>3</sub> are the columns of the 3 x 3 identity matrix I=eye(3), that is,

 1         0     0 <strong>e</strong>1 =  0 ,   <strong>e</strong>2 =  1 ,  <strong>e</strong>3 =  0 .

  0      0     1

<u>Type and display</u> GI in the Live Script.

**Then, calculate the actual products of G and each of the vectors <em>e e</em><sub>1</sub>, <sub>2</sub>, <em>e</em><sub>3</sub> (in the order indicated) – these products will form the columns of the matrix G*I (output and display G*I).




**Run a logical statement that would verify that your predicted matrix GI and the calculated matrix G*I match within the margin 10^(-7). If the matrices match, output a message that your prediction is correct – please make sure that you will receive this message.

<u>Important</u>: to compare two matrices, you need to use the function closetozeroroundoff with p=7 (this function was created in Project 0).

**Print <strong>closetozeroroundoff</strong> in your Live Script.

type closetozeroroundoff




**Next, complete one more task. Input a vector:

x=ones(3,1);

Output and <u>display</u> the image of this vector under the transformation defined by the matrix G.




We can define a<em> Toeplitz matrix</em> as an <em>m n</em><sub>×</sub> matrix in which each descending diagonal from left to right is constant. For example,

4 3 2 1<sub></sub>

<em>A</em>=<sup></sup><sub></sub>5 4 3 2<sup></sup><sub></sub>

<sub></sub>6 5 4 3<sub></sub>

is a 3 by 4 Toeplitz matrix.

<strong>Part 1</strong>. In this part, we will produce an <em>m n</em><sub>×</sub> Toeplitz matrix using a vector <strong>a</strong> with (<em>m</em><sub>+ −</sub><em>n </em>1) entries by assigning

<em>A i j</em>( , )=<strong>a</strong>(<em>n</em>+ −<em>i j</em>)      <em>i </em>=1:<em>m j</em>, =1:<em>n</em>.

In the example above, a 3 4<sub>×</sub> matrix A has been generated by the vector <strong>a</strong>=[1,2,3,4,5,6].

In this part of the exercise, you will write a code that creates an <em>m n</em><sub>×</sub> Toeplitz matrix, when possible. Then, you will run the function on the sets of variables <em>m</em>, <em>n</em>, and <strong>a</strong> to get the corresponding Toeplitz matrices.




**Create a function in the file that begins with function A=toeplitze(m,n,a)




Here, the inputs <em>m</em> and <em>n</em> will define the size of the Toeplitz matrix.

**First, your function has to check whether the number of entries in the vector <strong>a</strong> is

(<em>m</em><sub>+ −</sub><em>n </em>1). If it is not the case, output a message that the dimensions mismatch and assign an empty matrix to A. If vector <strong>a </strong>has exactly (<em>m</em><sub>+ −</sub><em>n </em>1) entries, output and <u>display</u> the Toeplitz matrix according to the formula given above.  <strong>This is the end of the function</strong> toeplitze.




**<strong>Print</strong> the function toeplitze in your Live Script.

type toeplitze




**<strong>Run</strong> the function A=toeplitze(m,n,a) on the following sets of variables (display the vector <strong>a</strong> for each of the below):

<ul>

 <li>m=4; n=2; a=1:5</li>

 <li>m=4; n=3; a=1:5</li>

 <li>m=4; n=3; a=1:7</li>

 <li>m=3; n=4; a=randi(10,1,6)</li>

 <li>m=4; n=4; a=[zeros(1,3), 1:4]</li>

</ul>




**Next, proceed in your Live Script with the following tasks:

<ul>

 <li>Type the vector <strong>a</strong> which defines a 6 by 6 <u>upper triangular</u> Toeplitz matrix with random integer entries in the range between 0 and 100. Display the vector <strong>a</strong>. Run the function A=toeplitze(m,n,a)on your <strong>a </strong>and the variables m,n indicated in this part.</li>

 <li>Output a 5 by 5 identity matrix by running the function A=toeplitze(m,n,a)on the corresponding set of variables. Display the vector <strong>a</strong> (which you need to construct first).</li>

</ul>




<strong>Part 2</strong>. MATLAB has a built-in function, called toeplitz<strong>,</strong> which takes a different approach to constructing a Toeplitz matrix. The specifications are on this page: <a href="https://www.mathworks.com/help/matlab/ref/toeplitz.html?s_tid=doc_ta">https://www.mathworks.com/help/matlab/ref/toeplitz.html?s_tid=doc_ta</a>




**(a) Output a (symmetric) Toeplitz matrix T by running a MATLAB built-in function

T=toeplitz(r) with

r=1:5;

**Run a logical statement in the Live Editor to verify that T is, indeed, a symmetric matrix. Output the corresponding message if it is the case.




**(b) By running the function T=toeplitz(c,r), output a 6 by 5 Toeplitz matrix with the same <em>r</em> and your choice of the vector <em>c</em> which should allow you to avoid the MATLAB “warning” about “conflicting” entries.

<h1>More on Matrices; Application</h1>




<u>Theory</u>: A vector with <u>nonnegative</u> entries is called a <strong>probability vector</strong> if the sum of its entries is 1. A square matrix is called <strong>right stochastic</strong> if its rows are probability vectors; a square matrix is called <strong>left stochastic</strong> if its columns are probability vectors; and a square matrix is called <strong>doubly stochastic</strong> if both, the rows and the columns, are probability vectors.




**Write a MATLAB function that begins with function [S1,S2,L,R]=stochastic(A)

L=[];

R=[];

<strong> </strong>

It accepts as the input a square matrix A with nonnegative entries. Outputs L and R will be the left stochastic and the right stochastic matrices generated, when possible, according to the instructions given below. You will also calculate and <u>display</u> the vectors S1=sum(A,1)and S2=sum(A,2) with the corresponding messages:

fprintf(‘the vector of sums down each column is
’) S1=sum(A,1)

fprintf(‘the vector of sums across each row is
’)

S2=sum(A,2)




Then, you will use a conditional statement to proceed with the tasks outlined below. You may also find it helpful to employ a logical command <strong>all</strong>.

**First, your function has to check whether A contains <u>both</u> a zero column and a zero row. If yes, output a message “A is neither left nor right stochastic and cannot be scaled to either of them”. The outputs L and R will be empty matrices (as assigned previously) – <u>the empty</u> <u>outputs should be suppressed</u>.

**Then, the function checks whether A is: (1) doubly stochastic (assign: L=A;R=A); or (2) only left stochastic (assign: L=A; R will stay empty), or (3) only right stochastic (assign R=A; L will stay empty). In each of these cases, also output a message that comments on the type of the matrix A.

**Finally, we consider a possibility that A is neither left nor right stochastic, but can be scaled to the left stochastic and/or to the right stochastic. You will output a message “A is neither left nor right stochastic but can be scaled to a stochastic matrix” and proceed with the scaling in the ways outlined below:

<ul>

 <li>If neither S1 nor S2 has a zero entry, we are <strong>scaling</strong>* A to the left stochastic matrix L and the right stochastic matrix R. You will also check if it is the case that the matrices L and R are equal – in this case, A has been scaled to a doubly stochastic matrix.</li>

 <li>If S1 does not have a zero entry but S2 does, we scale A only to the left stochastic matrix L (R stays empty).</li>

 <li>And, if S2 does not have a zero entry but S1 does, we scale A only to the right stochastic matrix R (L stays empty).</li>

</ul>

<u>Notes</u>: In each of the cases, the non-empty outputs have to be displayed with the corresponding messages. For the case of a doubly stochastic matrix, output the corresponding message and display either L or R – to determine if L=R, you will need to use the function <em>closetozeroroundoff</em> with p=7. ( This function was created in Project 0.)

<strong>*Scaling</strong>: To scale A to the left stochastic matrix L, we use vector S1 and multiply each column of A by the reciprocal of the corresponding entry of S1. To scale A to the right stochastic matrix R, we use the vector S2 and multiply each row of A by the reciprocal of the corresponding entry of S2.




**Print the functions stochastic, jord, and closetozeroroundoff in your Live Script.

(The function jord was created in Exercise 1 of this project.)

**Run the function [S1,S2,L,R]=stochastic(A) on each of the matrices below (display the input matrices in your Live Script):

<ul>

 <li>A=[0.5,0,0.5,0; 0,0,1,0;0.5,0,0.5,0;0,0,0,1]</li>

 <li>A = transpose(A)</li>

</ul>

(c)A=[0.5,  0,  0.5; 0,  0,  1; 0,  0,  0.5]

(d)A=transpose(A)

(e)A=[0.5,  0,  0.5; 0,  0.5,  0.5; 0.5,  0.5,  0]

(f)A=magic(3)

(g)B=[1 2;3 4;5 6]; A=B*B’

((h)A=jord(5,k)A=randi(10,5,5);A(:,1)=0;A4)<sup>    </sup>(1,:)=0




<u>NOTE</u>: Please make sure you will verify that all your outputs and messages match the corresponding definitions of the stochastic matrices. If not, make corrections in your code!




In this exercise, you will use <strong>Newton’s method</strong> to approximate a real zero of a given function.

<strong><u>Theory</u></strong>: A number <em>x</em> is a zero of a function <em>f</em> if <em>f x</em>( )=0. A real zero is an x-intercept of the function. Also, the <strong>zeros</strong> of a function <em>f</em> are the <strong>roots</strong> of the equation <em>f x</em>( )= 0.

To approximate a real zero of the function <em>f x</em>( ) by <strong>Newton’s method</strong>, we, first, choose an initial approximation <em>x</em><sub>0</sub> of the specified zero. The consecutive N iterations <em>x x</em><sub>1</sub>, <sub>2</sub>,…,<em>x</em><em><sub>N</sub></em> are defined by the formula:

<em>n</em>+          <em>n          f x</em>( <em>n</em>) ,   <em>n </em>= 0 : <em>N</em>.

<em>x </em>1 = −<em>x    f </em>‘(<em>x</em><em>n</em>)

<u>Note</u>: if <em>f </em>‘(<em>x</em>) is close to zero at an initial point <em>x</em><sub>0</sub>, the process will converge very slowly. It makes Newton’s method sensitive to the choice of an initial approximation.




<strong>In this exercise, you will work with two functions</strong>:  <em>F x</em>( )= arctan( )<em>x </em>+ −<em>x </em>1 and <em>G x</em>( )= − −<em>x</em><sup>3 </sup><em>x </em>1.




**First, you will create a <strong>function</strong> <strong>handle. </strong>Please refer to the documentation in MATLAB:

<a href="https://www.mathworks.com/help/matlab/matlab_prog/creating-a-function-handle.html?searchHighlight=handle&amp;s_tid=doc_srchtitle#buvu9u8-1">https://www.mathworks.com/help/matlab/matlab_prog/creating-a-function</a><a href="https://www.mathworks.com/help/matlab/matlab_prog/creating-a-function-handle.html?searchHighlight=handle&amp;s_tid=doc_srchtitle#buvu9u8-1">handle.html?searchHighlight=handle&amp;s_tid=doc_srchtitle#buvu9u8-1</a>

We will create handles to anonymous functions and calculate derivatives of the function handles as it follows.

**Begin with typing in the Live Script:

<table width="610">

 <tbody>

  <tr>

   <td width="610">format  format compactsyms xF = @(x) atan(x) + x – 1F1 = eval([‘@(x)’ char(diff(F(x)))]) <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0b4c364b">[email protected]</a>(x) x.^3-x-1</td>

  </tr>

 </tbody>

</table>

G1=eval([‘@(x)’ char(diff(G(x)))])




<u>Notes</u>: (1) a MATLAB command syms x defines a symbolic variable x;

(2) F and G are the function handles and F1 and G1 are the function handles for the first derivatives of F and G, respectively.




**Next, we create and output 2-D plots of the functions F, G, and y=0 on the interval [-2, 2]  in order to visualize the x-intercepts and choose initial approximations. An initial value <em>x</em><sub>0</sub> should be chosen close to the x-intercept which we are approximating.




**Type in the Live Script the code given below – it will output the graphs of F and G together with the function y=0 after you Run the section.




<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="61181b04130e5c21">[email protected]</a>(x) 0.*x.^(0)  x=linspace(-2,2); plot(x,F(x),x,yzero(x)); plot(x,G(x),x,yzero(x));

<u>Note</u>: here we have created another symbolic function yzero.




It is obvious from the properties of the function F(x) that it has only one real zero, which we will approximate. Concerning the function G, which is a polynomial of the third degree (we will denote it p), we are going to verify that it has only one real zero. In order to do that, we find all zeros of the polynomial p using MATLAB built-in functions sym2poly <sup>and  </sup>roots:

the function sym2poly(p) outputs the vector of the coefficients of the polynomial p (in descending order according to the degree), and the composition of two functions roots(sym2poly(p))outputs all zeros of the polynomial p.

**Type in the Live Script:

syms x p=x^3-x-1; roots(sym2poly(p))




After you Run Section, this part of the code will output the three zeros of the polynomial p – two of them are complex conjugate numbers and one is a real zero that we will approximate.




Next, we proceed with constructing a function in the file that approximates a real zero.

**Create a function called newtons. It begins with:

function root=newtons(fun,dfun,x0) format long

The inputs fun and dfun are the function and its first derivative, respectively, and x0 is the initial approximation. The output root will be <u>our</u> approximation of the real zero of a function. We will program consecutive iterations according to the Newton’s method, and we will assign to root the iteration which will be the first one falling within a margin of 10^(-12) from the MATLAB approximation x of that zero – the last is delivered by a built-in MATLAB function fzero. The details are below:

<strong>**</strong>Type the line  x=fzero(fun,x0)

in your function newtons and output x with a message that it is a MATLAB approximation of the real zero of the function.

**Then, your function newtons will calculate consecutive iterations <em>x</em><em><sub>n</sub></em>, <em>n </em><sub>= </sub>0: <em>N </em>, using Newton’s Method (see Theory above). You can employ a “while loop” here. The loop will terminate when, for the first time, abs( <em>x</em><em><sub>N </sub></em>-x)&lt;10^(-12) for some consecutive iteration <em>x</em><em><sub>N </sub></em>.

Output with a corresponding message the number of iterations N, and assign the last iteration, <em>x</em><em><sub>N </sub></em>,  to the output root.

<strong>This will be the end of your function</strong> newtons.




**Print the function newtons in your Live Script.

**Next, proceed with the following tasks in the Live Script:

<strong>Part (a)</strong>

You will work with the function F in this part. Using the graph of the function F, choose three different values of the initial approximation x0 of the zero of F.  **Then, input the function handles:

fun=F; dfun=F1;

and run the function root=newtons(fun,dfun,x0) for each of your three choices of  x0 – one at a time.

<strong> </strong>

<strong>Part (b) </strong>

You will work with the function G in this part.

**First, input the corresponding function handles.

**Then, run root=newtons(fun,dfun,x0) for each of the initial approximations (1)-(8) of the real zero of G:

<ul>

 <li>x0=1.3;</li>

 <li>x0=1;</li>

 <li>x0=0.6;</li>

 <li>x0=0.577351;</li>

 <li>Pick the initial value x0 to be the positive zero of the derivative of G(x). Type    x0=1/sqrt(3)</li>

</ul>

(display x0) and run the function root=newtons(fun,dfun,x0).

<ul>

 <li>x0=0.577;</li>

 <li>x0=0.4;</li>

 <li>x0=0.1;</li>

</ul>

<strong> </strong>

<strong>See next page for the BONUS on this Exercise</strong>.

Analyze the patterns of the consecutive iterations after you run your function newtons  on the choices of the initial approximations (1)-(8) in Part (b).




<strong>BONUS: 1 point!</strong>

% Describe the general pattern for the numbers of iterations which you observed for the choices (1)-(8), excluding choices (4)-(6) out of this sequence.




<strong>BONUS: 1 point! </strong>

% What did you notice when you run your function on choices (4)-(6)? How would you explain that “strange” pattern for the consecutive iterations?




<u>Hint</u>: to get the bonus points, you could <u>temporarily</u> display all intermediate iteration that  come from the “loop”. You may also need to review the Newton’s Method theory in more detail.


